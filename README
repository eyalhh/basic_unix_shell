

The implementation is as follows:
We will have a loop that outputs the string "myshell>" everytime, and waits for inputs.
We will check the input if its a "cd" or "exit" command, if so we will handle them manually.
If it's not a "cd" nor an "exit" command, we will use "fork" syscall to create a child process and then "execve" to change that child process image to the inputted command process image.

We will also have a separate file for the built-in commands, called builtin.s which contains the next functions:
1. void cd(char* directory); -> changes the directory from current directory to the inputted directory - using syscall chdir.
2. void exit(char* status); -> exits with status code (string of number) which will be in %rdi -> we would need to convert the string to a number in assembly.
3. void errorhandler(int errorcode); -> handles the error (outputs the corresponding output)

We will also have a file called "parsing_strings.s" which will have functions useful for parsing strings and comparing them:
1. int compare(char* str1, char* str2); -> will return 1 if they are equal 0 otherwise
2. void concatenate(char* str1, char* str2, char* dest) -> will concatenate str1+str2 and store the result in dest.
3. int length(char* str1) -> will return the length of str1 (until null termination)

We will also have a file called "io.s" which will have input output custom functions useful for printing to stdout and reading from stdin:
1. void print(char* str1, int length) -> will print str1 to stdout.
2. void read(char* buf, int maximum_length) -> will read input from stdin and put inside buf.

In the main.s file , the parsing of the input will go as follows:
execve structure:
int execve(const char* filename, const char* argv[], const char* envp[]);
for the filename, of course, we would need the full path(e.g. pwd -> /bin/pwd)
for the argv, we would just reserve 8200 bytes in bss that will store pointers to the strings of the arguments (including the name of the command
calculation : 1024 (maximum seperate strings) * 8 (address size in x86_64) + 8 (8 zero bytes at the end to indicate null termination) = 8200
of course, by c calling convention and the man page for syscalls:
filename -> rdi
argv[] -> rsi
envp[] -> rdx
for rdx we would just use zero because we dont use any environment variables.

How will we handle the common errors:
the errorcode for each syscall in assembly will be returned at rax (negative)
so we will neg %rax, and then cmp rax to each possible errorcode(of both chdir and execve) :
1. ERRNO = 1  -> operation not permitted.
2. ERRNO = 2  -> no such file or directory error.
3. ERRNO = 7  -> argument list too long error.
4. ERRNO = 8  -> exec format error.
5. ERRNO = 12 -> out of memory error.
6. ERRNO = 13 -> permission denied error.
7. ERRNO = 14 -> bad address error.
8. ERRNO = 20 -> not a directory error.
9. ERRNO = 22 -> inavlid argument error.
and output the corresponding string of course {Error: $(Err_message)}
this function would be :
void error_handler(int errorcode);
and will live in the builtin.s file.

How to Run

    Install Git (if you don't have it)

        On Ubuntu/Debian: sudo apt-get update && sudo apt-get install git

        On macOS: brew install git

        On Windows: Download and install Git from https://git-scm.com/.

    Clone the repository

    Run the following command to clone the repository: git clone https://github.com/eyalhh/basic_unix_shell.git

    Build the project

    Navigate to the project directory: cd <project_directory>

    Then compile the project using: make

    Run the shell emulator

    Finally, run the shell emulator: ./myshell
