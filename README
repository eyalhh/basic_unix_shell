

The implementation is as follows:
We will have a loop that outputs the string "myshell>" everytime, and waits for inputs.
We will check the input if its a "cd" or "exit" command, if so we will handle them manually.
If it's not a "cd" nor an "exit" command, we will use "fork" syscall to create a child process and then "execve" to change that child process image to the inputted command process image.
We will also have a separate file for the built-in commands, called builtin.s which contains the next functions:
int cd(char* directory);
(returns 1 if success -1 if error) - the function itself already handles the errors
which changes the directory from current directory to the inputted directory.
void exit(int status); - the function just exits with status code which will be in %rdi (simple syscall)

We will also have a file called "parsing_strings.s" which will have functions useful for parsing strings and comparing them:
1. int compare(char* str1, char* str2, int length); -> will return 1 if they are equal 0 otherwise

In the main.s file , the parsing of the input will go as follows:
execve will need the name of the command (pointer to the string containing that name), which will the pointer to the whole buffer.
execve will the need the arguments of the command (+flags) - (in assembly, we are actually passing the pointers to those arguments strings, for that
we will put aside extra memory near the buffer to store the offsets of the arguments strings in the buffer (seperated by a space) - will have max size of 1024 as well to ensure that
all possible commands are handled.
then, when calling execve , we will put the first six arguments in rdi,rsi,rdx,rcx,r8,r9, then we would just read the rest from the stack.
How will we handle the common errors:
1.